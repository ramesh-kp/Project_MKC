MODBUS Message Format
---------------------
    * The MODBUS protocol defines the format for the master’s query and the slave’s response.
    * The query contains: 
        the device (or broadcast) address, 
        a function code defining the requested action, 
        any data to be sent, 
        and an error-checking field.
    * The response contains:
        fields confirming the action taken, 
        any data to be returned, 
        and an error-checking field. 
    * If an error occurred in receipt of the message, or if the slave is unable to perform the requested
      action, the slave will construct an error message and send it as its response.

Query
-----
    The example illustrates a request for a single 16-bit Modbus Register.
    
    Slave Address: 
        8-bit value representing the slave being addressed (1 to 247), 0 is reserved for the broadcast address. 
        The SPR and Integra products do not support the broadcast address.
    Function Code:
        8-bit value telling the addressed slave what action is to be performed. 
        (3, 4, or 16 are valid for Integra)
    Start Address (Hi):
        The top (most significant) eight bits of a 16-bit number specifying the start address of the data being requested.
    Start Address (Lo):
        The bottom (least significant) eight bits of a 16-bit number specifying the start address of the data being requested.
    Number of Points (Hi):
        The top (most significant) eight bits of a 16-bit number specifying the number of registers being requested.
    Number of Points (Lo):
        The bottom (least significant) eight bits of a 16-bit number specifying the number of registers being requested.
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

Response
--------
    The example illustrates the normal response to a request for a single 16-bit Register.

    Slave Address:
        8-bit value representing the address of slave, which has just responded.
    Function Code:
        8-bit value which, when a copy of the function code in the query, 
        indicates that the slave recognised the query and has responded. (See also Exception Response).
    Byte Count:
        8-bit value indicating the number of data bytes contained within this response 
    Data (Hi):
        The top (most significant) eight bits of a 16-bit number representing the register(s) requested in the query.
    Data (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the register(s) requested in the query.
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

Exception Response
------------------
    If an error is detected in the content of the query (excluding parity errors and Error Check mismatch), 
    the function code will be modified to indicate that the response is an error response (called an exception response), 
    and the data bytes will contain a code that describes the error. 
    The exception response is identified by the function code being a copy of the query function code but with the 
    most-significant bit set to logic ‘1’.

    Slave Address: 
        8 bit value representing the address of slave, which has just responded.
    Function Code:
        8 bit value which is the function code in the query OR'ed with Hex (80),
        indicating the slave either does not recognise the query or could not carry out the action requested.
    Error Code:
        8 bit value indicating the nature of the exception detected. 
        (See “Exception Codes“ in the section “Product Information for a list of SPR and Integra supported codes).
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

The Serial Transmission Mode - RTU Mode
----------------------------------------
    In RTU (Remote Terminal Unit) mode, each 8-bit byte in a message contains two 4-bit hexadecimal characters. 
    The main advantage of this mode is that its greater character density allows better data throughput than ASCII for the 
    same baud rate, however each message must be transmitted in a continuous stream.
    The format for each byte in RTU mode is:

    Coding System:
        8-bit binary, hexadecimal 0-9, A-F Two hexadecimal characters contained in each 8-bit field of the message.
    Bits per Byte:
        1 start bit, 
        8 data bits, least significant bit sent first 
        1 parity bit for even/odd parity; no parity bit for no parity
        1 stop bit if parity is used; 2 stop bits if no parity
    Error Check Field:
        Cyclical Redundancy Check (CRC)

    The SPR and Integra products support MODBUS RTU mode. 
    Integra additionally supports a common alternative format with 1 stop bit and no parity.

MODBUS Message Timing (RTU Mode)
--------------------------------
    A MODBUS message has defined beginning and ending points. 
    The receiving devices recognise the start of the message, 
    read the “Slave Address” to determine if they are being addressed and 
    know when the message is completed so that they can use the Error Check bytes to confirm the integrity of the query.
    Partial messages can be detected and discarded.
    In RTU mode, messages start with a silent interval of at least 3.5 character times.
    The first field then transmitted is the device address.
    The allowable characters transmitted for all fields are hexadecimal 0-9, A-F. 
    Devices monitor the network bus continuously, including during the ‘silent’ intervals. 
    When the first field (the address field) is received, each device decodes it to find out if it is the addressed device. 
    If the device determines that it is the one being addressed it decodes the whole message and acts accordingly, 
    if it is not being addressed it continues monitoring for the next message.
    Following the last transmitted character, a silent interval of at least 3.5 character times marks the end of the message. 
    A new message can begin after this interval.
    In the Integra 1000 and 2000, a silent interval of 60msec minimum is required in order to guarantee successful 
    reception of the next request.
    The entire message frame must be transmitted as a continuous stream. 
    If a silent interval of more than 1.5 character times occurs before completion of the frame, 
    the receiving device flushes the incomplete message and assumes that the next byte will be 
    the address field of a new message.
    Similarly, if a new message begins earlier than 3.5 character times following a previous message, 
    the receiving device will consider it a continuation of the previous message. 
    This will result in an error, as the value in the final CRC field will not be valid for the combined messages.

How Characters are Transmitted Serially
---------------------------------------
    When messages are transmitted on standard MODBUS serial networks each character or byte is sent in this order 
    (left to right).
        With Parity Checking (11 bit characters):
            One start bit, 8 bit data, one parity bit and one stop bit.
        Without Parity Checking, 2 Stop Bits (11 bit characters):
            One start bit, 8 bit data and two stop bits.
        The Integra products additionally support No parity, One stop bit (10 bit characters):
            One start bit, 8 bit data and one stop bit.

Error Checking Methods
----------------------
    Standard MODBUS serial networks use two error checking processes, the error check bytes mentioned above 
    check message integrity whilst Parity checking (even or odd) can be applied to each character in the message.
    The master is configured by the user to wait for a predetermined timeout interval. 
    The master will wait for this period of time before deciding that the slave is not going to respond and 
    that the transaction should be aborted. 
    Care must be taken when determining the timeout period from both the master and the slaves specifications. 
    The slave may define the ‘response time’ as being the period from the receipt of the last bit of the query 
    to the transmission of the first bit of the response. 
    The master may define the ‘response time’ as period between transmitting the first bit of the query 
    to the receipt of the last bit of the response. 
    It can be seen that message transmission time, which is a function of the baud rate, 
    must be included in the timeout calculation.

Parity Checking
---------------
    If parity checking is enabled - either Even or Odd Parity is specified - the quantity of “1’s” will be counted in
    the data portion of each of the eight bits in the character. 
    The parity bit will then be set to a 0 or 1 to result in an Even or Odd total of “1’s”.
    Note that parity checking can only detect an error if an odd number of bits are picked up or dropped in a character frame 
    during transmission, if for example two 1’s are corrupted to 0’s the parity check will not find the error.
    If No Parity checking is specified, no parity bit is transmitted and no parity check can be made. 
    An additional stop bit is transmitted to fill out the character frame when 2 stop bits are selected.
    If No Parity checking is specified and one stop bit is selected the character is effectively shortened by one bit.

CRC Checking
------------
    The error check bytes of the MODBUS messages contain a Cyclical Redundancy Check (CRC) value that is used to check 
    the content of the entire message. 
    The error check bytes must always be present to comply with the MODBUS protocol; there is no option to disable it.
    The error check bytes represent a 16-bit binary value, calculated by the transmitting device. 
    The receiving device must recalculate the CRC during receipt of the message and compare the calculated value to the
    value received in the error check bytes. 
    If the two values are not equal, the message should be discarded.
    The error check calculation is started by first pre-loading a 16-bit register to all 1’s (i.e. Hex (FFFF)) each
    successive 8-bit byte of the message is applied to the current contents of the register. 
    Note: only the eight bits of data in each character are used for generating the CRC, start bits, stop bits and 
    the parity bit, if one is used, are not included in the error check bytes.
    During generation of the error check bytes, each 8-bit character is exclusive OR'ed with the register contents. 
    The result is shifted in the direction of the least significant bit (LSB), with a zero filled into the 
    most significant bit (MSB) position. 
    The LSB prior to the shift is extracted and examined. 
    If the LSB was a 1, the register is then exclusive OR'ed with a pre-set, fixed value. 
    If the LSB was a 0, no exclusive OR takes place.
    This process is repeated until eight shifts have been performed. 
    After the last (eighth) shift, the next 8-bit byte is exclusive OR'ed with the register’s current value, 
    and the process repeated. 
    The final contents of the register, after all the bytes of the message have been applied, is the error check value.
    
    Example
    ......
    In the following pseudo code “ErrorWord” is a 16-bit value representing the error check values.

    BEGIN
        ErrorWord = Hex (FFFF)
            FOR Each byte in message
                ErrorWord = ErrorWord XOR byte in message
                    FOR Each bit in byte
                        LSB = ErrorWord AND Hex (0001)
                        IF LSB = 1 THEN ErrorWord = ErrorWord – 1
                        ErrorWord = ErrorWord / 2
                IF LSB = 1 THEN ErrorWord = ErrorWord XOR Hex (A001)
                    NEXT bit in byte
            NEXT Byte in message
    END

Function Codes
--------------
    The function code part of a MODBUS message defines the action to be taken by the slave. 
    The SPR and Integra products support the following function codes:

    Code        :   03
    MODBUS name :   Read Holding Registers
    Description :   Read the contents of read/write location

    Code        :   04
    MODBUS name :   Read Input Registers
    Description :   Read the contents of read only location

    Code        :   08
    MODBUS name :   Diagnostics
    Description :   Only sub-function zero is supported. 
                    This returns the data element of the query unchanged.

    Code        :   16
    MODBUS name :   Pre-set Multiple Registers
    Description :   Set the contents of read/write location      

Product Specific Considerations
-------------------------------


