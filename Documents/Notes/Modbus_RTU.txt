MODBUS Message Format
---------------------
    * The MODBUS protocol defines the format for the master’s query and the slave’s response.
    * The query contains: 
        the device (or broadcast) address, 
        a function code defining the requested action, 
        any data to be sent, 
        and an error-checking field.
    * The response contains:
        fields confirming the action taken, 
        any data to be returned, 
        and an error-checking field. 
    * If an error occurred in receipt of the message, or if the slave is unable to perform the requested
      action, the slave will construct an error message and send it as its response.

Query
-----
    The example illustrates a request for a single 16-bit Modbus Register.
    
    Slave Address: 
        8-bit value representing the slave being addressed (1 to 247), 0 is reserved for the broadcast address. 
        The SPR and Integra products do not support the broadcast address.
    Function Code:
        8-bit value telling the addressed slave what action is to be performed. 
        (3, 4, or 16 are valid for Integra)
    Start Address (Hi):
        The top (most significant) eight bits of a 16-bit number specifying the start address of the data being requested.
    Start Address (Lo):
        The bottom (least significant) eight bits of a 16-bit number specifying the start address of the data being requested.
    Number of Points (Hi):
        The top (most significant) eight bits of a 16-bit number specifying the number of registers being requested.
    Number of Points (Lo):
        The bottom (least significant) eight bits of a 16-bit number specifying the number of registers being requested.
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

Response
--------
    The example illustrates the normal response to a request for a single 16-bit Register.

    Slave Address:
        8-bit value representing the address of slave, which has just responded.
    Function Code:
        8-bit value which, when a copy of the function code in the query, 
        indicates that the slave recognised the query and has responded. (See also Exception Response).
    Byte Count:
        8-bit value indicating the number of data bytes contained within this response 
    Data (Hi):
        The top (most significant) eight bits of a 16-bit number representing the register(s) requested in the query.
    Data (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the register(s) requested in the query.
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

Exception Response
------------------
    If an error is detected in the content of the query (excluding parity errors and Error Check mismatch), 
    the function code will be modified to indicate that the response is an error response (called an exception response), 
    and the data bytes will contain a code that describes the error. 
    The exception response is identified by the function code being a copy of the query function code but with the 
    most-significant bit set to logic ‘1’.

    Slave Address: 
        8 bit value representing the address of slave, which has just responded.
    Function Code:
        8 bit value which is the function code in the query OR'ed with Hex (80),
        indicating the slave either does not recognise the query or could not carry out the action requested.
    Error Code:
        8 bit value indicating the nature of the exception detected. 
        (See “Exception Codes“ in the section “Product Information for a list of SPR and Integra supported codes).
    Error Check (Lo):
        The bottom (least significant) eight bits of a 16-bit number representing the error check value.
    Error Check (Hi):
        The top (most significant) eight bits of a 16-bit number representing the error check value.

The Serial Transmission Mode - RTU Mode
----------------------------------------
    In RTU (Remote Terminal Unit) mode, each 8-bit byte in a message contains two 4-bit hexadecimal characters. 
    The main advantage of this mode is that its greater character density allows better data throughput than ASCII for the 
    same baud rate, however each message must be transmitted in a continuous stream.
    The format for each byte in RTU mode is:

    Coding System:
        8-bit binary, hexadecimal 0-9, A-F Two hexadecimal characters contained in each 8-bit field of the message.
    Bits per Byte:
        1 start bit, 
        8 data bits, least significant bit sent first 
        1 parity bit for even/odd parity; no parity bit for no parity
        1 stop bit if parity is used; 2 stop bits if no parity
    Error Check Field:
        Cyclical Redundancy Check (CRC)

    The SPR and Integra products support MODBUS RTU mode. 
    Integra additionally supports a common alternative format with 1 stop bit and no parity.

MODBUS Message Timing (RTU Mode)
--------------------------------
    A MODBUS message has defined beginning and ending points. 
    The receiving devices recognise the start of the message, 
    read the “Slave Address” to determine if they are being addressed and 
    know when the message is completed so that they can use the Error Check bytes to confirm the integrity of the query.
    Partial messages can be detected and discarded.
    In RTU mode, messages start with a silent interval of at least 3.5 character times.
    The first field then transmitted is the device address.
    The allowable characters transmitted for all fields are hexadecimal 0-9, A-F. 
    Devices monitor the network bus continuously, including during the ‘silent’ intervals. 
    When the first field (the address field) is received, each device decodes it to find out if it is the addressed device. 
    If the device determines that it is the one being addressed it decodes the whole message and acts accordingly, 
    if it is not being addressed it continues monitoring for the next message.
    Following the last transmitted character, a silent interval of at least 3.5 character times marks the end of the message. 
    A new message can begin after this interval.
    In the Integra 1000 and 2000, a silent interval of 60msec minimum is required in order to guarantee successful 
    reception of the next request.
    The entire message frame must be transmitted as a continuous stream. 
    If a silent interval of more than 1.5 character times occurs before completion of the frame, 
    the receiving device flushes the incomplete message and assumes that the next byte will be 
    the address field of a new message.
    Similarly, if a new message begins earlier than 3.5 character times following a previous message, 
    the receiving device will consider it a continuation of the previous message. 
    This will result in an error, as the value in the final CRC field will not be valid for the combined messages.

How Characters are Transmitted Serially
---------------------------------------
    When messages are transmitted on standard MODBUS serial networks each character or byte is sent in this order 
    (left to right).
        With Parity Checking (11 bit characters):
            One start bit, 8 bit data, one parity bit and one stop bit.
        Without Parity Checking, 2 Stop Bits (11 bit characters):
            One start bit, 8 bit data and two stop bits.
        The Integra products additionally support No parity, One stop bit (10 bit characters):
            One start bit, 8 bit data and one stop bit.

Error Checking Methods
----------------------
    Standard MODBUS serial networks use two error checking processes, the error check bytes mentioned above 
    check message integrity whilst Parity checking (even or odd) can be applied to each character in the message.
    The master is configured by the user to wait for a predetermined timeout interval. 
    The master will wait for this period of time before deciding that the slave is not going to respond and 
    that the transaction should be aborted. 
    Care must be taken when determining the timeout period from both the master and the slaves specifications. 
    The slave may define the ‘response time’ as being the period from the receipt of the last bit of the query 
    to the transmission of the first bit of the response. 
    The master may define the ‘response time’ as period between transmitting the first bit of the query 
    to the receipt of the last bit of the response. 
    It can be seen that message transmission time, which is a function of the baud rate, 
    must be included in the timeout calculation.

Parity Checking
---------------
    If parity checking is enabled - either Even or Odd Parity is specified - the quantity of “1’s” will be counted in
    the data portion of each of the eight bits in the character. 
    The parity bit will then be set to a 0 or 1 to result in an Even or Odd total of “1’s”.
    Note that parity checking can only detect an error if an odd number of bits are picked up or dropped in a character frame 
    during transmission, if for example two 1’s are corrupted to 0’s the parity check will not find the error.
    If No Parity checking is specified, no parity bit is transmitted and no parity check can be made. 
    An additional stop bit is transmitted to fill out the character frame when 2 stop bits are selected.
    If No Parity checking is specified and one stop bit is selected the character is effectively shortened by one bit.

CRC Checking
------------
    The error check bytes of the MODBUS messages contain a Cyclical Redundancy Check (CRC) value that is used to check 
    the content of the entire message. 
    The error check bytes must always be present to comply with the MODBUS protocol; there is no option to disable it.
    The error check bytes represent a 16-bit binary value, calculated by the transmitting device. 
    The receiving device must recalculate the CRC during receipt of the message and compare the calculated value to the
    value received in the error check bytes. 
    If the two values are not equal, the message should be discarded.
    The error check calculation is started by first pre-loading a 16-bit register to all 1’s (i.e. Hex (FFFF)) each
    successive 8-bit byte of the message is applied to the current contents of the register. 
    Note: only the eight bits of data in each character are used for generating the CRC, start bits, stop bits and 
    the parity bit, if one is used, are not included in the error check bytes.
    During generation of the error check bytes, each 8-bit character is exclusive OR'ed with the register contents. 
    The result is shifted in the direction of the least significant bit (LSB), with a zero filled into the 
    most significant bit (MSB) position. 
    The LSB prior to the shift is extracted and examined. 
    If the LSB was a 1, the register is then exclusive OR'ed with a pre-set, fixed value. 
    If the LSB was a 0, no exclusive OR takes place.
    This process is repeated until eight shifts have been performed. 
    After the last (eighth) shift, the next 8-bit byte is exclusive OR'ed with the register’s current value, 
    and the process repeated. 
    The final contents of the register, after all the bytes of the message have been applied, is the error check value.
    
    Example
    ......
    In the following pseudo code “ErrorWord” is a 16-bit value representing the error check values.

    BEGIN
        ErrorWord = Hex (FFFF)
            FOR Each byte in message
                ErrorWord = ErrorWord XOR byte in message
                    FOR Each bit in byte
                        LSB = ErrorWord AND Hex (0001)
                        IF LSB = 1 THEN ErrorWord = ErrorWord – 1
                        ErrorWord = ErrorWord / 2
                IF LSB = 1 THEN ErrorWord = ErrorWord XOR Hex (A001)
                    NEXT bit in byte
            NEXT Byte in message
    END

Function Codes
--------------
    The function code part of a MODBUS message defines the action to be taken by the slave. 
    The SPR and Integra products support the following function codes:

    Code        :   03
    MODBUS name :   Read Holding Registers
    Description :   Read the contents of read/write location

    Code        :   04
    MODBUS name :   Read Input Registers
    Description :   Read the contents of read only location

    Code        :   08
    MODBUS name :   Diagnostics
    Description :   Only sub-function zero is supported. 
                    This returns the data element of the query unchanged.

    Code        :   16
    MODBUS name :   Pre-set Multiple Registers
    Description :   Set the contents of read/write location      

Product Specific Considerations
-------------------------------
    The MODBUS protocol defines “Registers” for the variables; a register is 16 bits long. 
    The bits in an IEEE 754 format have the following significance:
        24 - 31 bits    :   Data Hi Word, Hi Byte   :   SEEE EEEE
        16 - 23 bits    :   Data Hi Word, Lo Byte   :   EMMM MMMM
        8 - 15 bits     :   Data Lo Word, Hi Byte   :   MMMM MMMM
        0 - 7 bits      :   Data Lo Word, Lo Byte   :   MMMM MMMM
    Where:
        S   :   the sign bit where 1 is negative and 0 is positive
        E   :   E is the two’s complement exponent with an offset of 127 i.e. an exponent of zero is represented by
                127, an exponent of 1 by 128 etc.
        M   :   M is the 23-bit normal mantissa. The highest bit is always 1 and, therefore, is not stored.
    
    Using the above format the floating point number 240.5 is represented as <43><70><80><00>:
        24 - 31 bits    :   43
        16 - 23 bits    :   70
        8 - 15 bits     :   80
        0 - 7 bits      :   00
    
        24 - 31 bits    :   0100 0011
        16 - 23 bits    :   0111 0000
        8 - 15 bits     :   1000 0000
        0 - 7 bits      :   0000 0000

    From this you can determine the following information.
        The sign bit is 0, indicating a positive number.
        The exponent value is 10000110 binary or 134 decimal. 
        Subtracting 127 from 134 leaves 7, which is the actual exponent.
        The mantissa appears as the binary number 11100001000000000000000.
        There is an implied decimal point at the left of the mantissa that is always preceded by a 1. 
        This digit is not stored in the hexadecimal representation of the floating-point number. 
        Adding 1 and the decimal point to the beginning of the mantissa gives the following: 1.11100001000000000000000
        Now, we adjust the mantissa for the exponent. 
        A negative exponent moves the decimal point to the left. 
        A positive exponent moves the decimal point to the right. 
        Because the exponent is 7, the mantissa is adjusted as follows: 11110000.1000000000000000
        Finally, we have a binary floating-point number. 
        Binary digits that are to the left of the decimal point represent the power of two corresponding to their position. 
        For example, 
        11110000 represents (1 x 2^7) + (1 x 2^6) + (1 x 2^5) + (1 x 2^4) + (0 x 2^3)+ (0 x 2^2) + (0 x 2^1)+ (0 x 2^0) = 240.
        Binary digits that are to the right of the decimal point also represent a power of 2 corresponding to their position. 
        As the digits are to the right of the decimal point the powers are negative. 
        For example: 
        100 represents (1 x 2^-1) + (0 x 2^-2)+ (0 x 2^-3) + … which equals 0.5.
        Adding these two numbers together and making reference to the sign bit produces the number +240.5.
        
MODBUS Commands supported
    All Crompton Integra Instruments support 
        the “Read Input Register” (3X registers), 
        the “Read Holding Register” (4X registers) and 
        the “Pre-set Multiple Registers” (write 4X registers) 
        commands of the MODBUS RTU protocol. 
    All values stored and returned are in floating point format to IEEE 754 with the most significant byte first.

    Read Input Registers
        MODBUS code 04 reads the contents of the 3X registers.
        Example:
            The following query will request ‘Volts 1’ from an instrument with node address 1:
            The Field Names are mentioned below
            Slave Address           :   01
            Function                :   04
            Starting Address High   :   00
            Starting Address Low    :   00
            Number of Points High   :   00
            Number of Points Low    :   02
            Error Check Low         :   71
            Error Check High        :   CB
        Note: Data must be requested in register pairs i.e. 
        the “Number of Points” must be even to request a floating point variable. 
        If the “Number of points” is odd or the “Starting Address” falls in the middle of a floating point variable 
        the product will return an error message.
        Example:
            The following response returns the contents of Volts 1 as 230.2
            The Field Names are mentioned below
            Slave Address               :   01
            Function                    :   04
            Byte Count                  :   04
            Data, High Word, High Byte  :   43
            Data, High Word, Low Byte   :   66
            Data, Low Word, High Byte   :   33
            Data, Low Word, Low Byte    :   34
            Error Check Low             :   1B
            Error Check High            :   38

    Read Holding Registers
        MODBUS code 03 reads the contents of the 4X registers.
        Example:
            The following query will request the prevailing ‘Demand Time’:
            The Field Names are mentioned below
            Slave Address               :   01
            Function                    :   03
            Starting Address High       :   00
            Starting Address Low        :   00
            Number of Points High       :   00
            Number of Points Low        :   02
            Error Check Low             :   C4
            Error Check High            :   0B
        Note: Data must be requested in register pairs i.e. 
        the “Number of Points” must be even to request a floating point variable. 
        If the “Number of points” is odd or the “Starting Address” falls in the middle of a floating point variable 
        the Integra products will return an error message.
        Example:
            The following response returns the contents of Demand Time as 1
            The Field Names are mentioned below
            Slave Address               :   01
            Function                    :   03
            Byte Count                  :   04
            Data, High Word, High Byte  :   3F
            Data, High Word, Low Byte   :   80
            Data, Low Word, High Byte   :   00
            Data, Low Word, Low Byte    :   00
            Error Check Low             :   F7
            Error Check High            :   CF

Write Holding Registers
    MODBUS code 16 decimal (10 Hex) writes the contents of the 4X registers.
    Example:
        The following query will set the Demand Time to zero, which effectively resets the Demand Period:
        The Field Names are mentioned below
        Slave Address                   :   01
        Function                        :   10
        Starting Address High           :   00
        Starting Address Low            :   00
        Number of Registers High        :   00
        Number of Registers Low         :   02
        Byte Count                      :   04
        Data, High Word, High Byte      :   00
        Data, High Word, Low Byte       :   00
        Data, Low Word, High Byte       :   00
        Data, Low Word, Low Byte        :   00
        Error Check Low                 :   3D
        Error Check High                :   23
    Note: Data must be written in register pairs i.e. 
    the “Number of Points” must be even to set a floating point variable. 
    If the “Number of points” is odd or the “Starting Address” falls in the middle of a floating point variable 
    the Integra products will return an error message.
    
    The following response indicates that the write has been successful.
    The Field Names are mentioned below
    Slave Address               :   01
    Function                    :   10
    Starting Address High       :   00
    Starting Address Low        :   00
    Number of Registers High    :   00
    Number of Registers Low     :   02
    Error Check Low             :   41
    Error Check High            :   C8

Diagnostics
    MODBUS code 08 provides a number of diagnostic sub-functions. 
    Only the “Return Query Data” subfunction (sub-function 0) is supported on the Integra 1540, 1560, 1580.
    Example:
        The following query will send a diagnostic “return query data” query with the data elements set to 
        Hex(AA) and Hex(55) and will expect these to be returned in the response:
        The Field Names are mentioned below
        Slave Address           :   01
        Function                :   08
        Sub-Function High       :   00
        Sub-Function Low        :   00
        Data Byte 1             :   AA
        Data Byte 2             :   55
        Error Check Low         :   5E
        Error Check High        :   94
    Note: Data must be written in register pairs i.e. 
    the “Number of Points” must be even. 
    If the “Number of points” is odd or the “Starting Address” falls in the middle of a floating point variable 
    product will return an error message.

    The following response indicates the correct reply to the query.
    The Field Names are mentioned below
    Slave Address           :   01
    Function                :   08
    Sub-Function High       :   00
    Sub-Function Low        :   00
    Data Byte 1             :   AA
    Data Byte 2             :   55
    Error Check Low         :   5E
    Error Check High        :   94

When things go wrong
    Start with a simple network, one master and one slave, with SPR and Integra products this is easily
        achieved as the network can be left intact whilst individual instruments are disconnected by removing
        the RS485 connector from the rear of the instrument.
    Check that all the “A’s” are connected together, check that all the “B’s” are connected together, check
        that all the “Gnd’s” are connected together.
    If using SpecView or PCView (PC software) with a RS232 to RS485 converter confirm that the data
        “transmitted” onto the RS485 is not echoed back to the PC on the RS232 lines. (This facility is
        sometimes a link option within the converter). Many PC based packages seem to be “confused” when
        they receive an echo of the message they are transmitting.
    Confirm that the Address of the instrument is the same as the “master” is expecting.
    If the “network” operates with one instrument but not more than one check that each instrument has a
        unique address.
    Each request for data must be restricted to 20 parameters (40 in the case of the 1500 Series) or less.
        Violating this requirement will impact the performance of the instrument and may result in a response
        time in excess of the specification.
    Check that the MODBUS mode (RTU or ASCII) and serial parameters (baud rate, number of data
        bits, number of stop bits and parity) are the same for all devices on the network.
    Check that the “master” is requesting floating-point variables (pairs of registers placed on floating
        point boundaries) and is not “splitting” floating point variables.
    Check that the floating-point byte order expected by the “master” is the same as that used by the
        SPR and Integra products. (PCView and Citect packages can use a number of formats including that
        supported by SPR and Integra).
    If possible obtain a second RS232 to RS485 converter and connect it between the RS485 bus and an
        additional PC equipped with a software package, which can display the data on the bus. Check for
        the existence of valid requests.

Product Information
-------------------
*** Yet to complete


ABB Water Flowmeter
-------------------
Modbus protocol
    Transmission    :   Modbus RTU - RS485 serial connection
    Baud rate       :   2400, 4800, 9600, 19200, 38400, 56000, 57600, 115200 baud
                        Factory setting :   9600 baud
    Parity          :   None, even, odd
                        Factory setting :   odd
    Stop bit        :   One, two
                        Factory setting :   One
    IEEE format     :   Little endian, big endian
                        Factory setting :   Little endian
    Response delay time :   0 to 200 milliseconds
                            Factory setting :   10 milliseconds


Need to find the height of the pipe in the well and dam.
